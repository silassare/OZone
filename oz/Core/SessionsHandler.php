<?php
	/**
	 * Copyright (c) Emile Silas Sare <emile.silas@gmail.com>
	 *
	 * This file is part of OZone (O'Zone) package.
	 *
	 * For the full copyright and license information, please view the LICENSE
	 * file that was distributed with this source code.
	 */

	namespace OZONE\OZ\Core;

	use Gobl\DBAL\Rule;
	use OZONE\OZ\Db\OZSession;
	use OZONE\OZ\Db\OZSessionsQuery;
	use OZONE\OZ\Db\OZUser;
	use OZONE\OZ\Exceptions\InternalErrorException;

	defined('OZ_SELF_SECURITY_CHECK') or die;

	final class SessionsHandler implements \SessionHandlerInterface
	{
		/**
		 * @var \OZONE\OZ\Core\SessionsHandler
		 */
		private static $instance;

		/**
		 * @var bool
		 */
		private static $started = false;

		/**
		 * Fetched data cache.
		 *
		 * @var array[]
		 */
		private static $fetch_cache = [];

		/**
		 * SessionsHandler constructor.
		 */
		private function __construct() { }

		/**
		 * For debugging.
		 *
		 * @param $log
		 */
		private static function log($log)
		{
			// oz_logger($log);
		}

		/**
		 * Start the session.
		 *
		 * When the session was already started
		 * you should restart a new one.
		 *
		 * @throws \Exception
		 */
		public static function start()
		{
			self::register();

			if (self::$started) {
				throw new \Exception('Session already started. You should try to restart.');
			}

			self::$started = true;
			$sid_name      = SettingsManager::get('oz.config', 'OZ_API_SESSION_ID_NAME');

			if (isset($_COOKIE[$sid_name]) AND !empty($_COOKIE[$sid_name])) {
				$session_id = $_COOKIE[$sid_name];
				$fetch      = self::fetch($session_id);
				// we destroy the current session
				if ($fetch['usable'] == false OR $fetch['exists'] == false) {
					// session id is not usable or was deleted or is a fake one
					// anyway we should not trust in user
					if (isset($_SESSION)) {
						session_destroy();
					}

					self::setNewSessionId();
				} else {
					// we will just update session cookie header
					self::updateSessionCookieHeader($session_id);
				}
			} else {
				// we have a new user
				self::setNewSessionId();
			}

			// set default cookie params before session start
			$params = self::getCookieParams();
			session_set_cookie_params($params['lifetime'], $params['path'], $params['domain'], $params['secure'], $params['httponly']);

			session_start();

			self::log(['start', session_id()]);
		}

		/**
		 * Restart the session.
		 *
		 * @throws \Exception
		 */
		public static function restart()
		{
			if (session_status() !== PHP_SESSION_ACTIVE) {
				session_start();
			}

			session_unset();
			session_destroy();
			self::setNewSessionId();
			session_start();
		}

		/**
		 * Register this session handler
		 *
		 * @throws \Exception
		 */
		private static function register()
		{
			if (!isset(self::$instance)) {
				$sid_name       = SettingsManager::get('oz.config', 'OZ_API_SESSION_ID_NAME');
				self::$instance = new self();
				session_cache_limiter('nocache');
				session_set_save_handler(self::$instance, true);

				// we force the execution just before the destruction
				// of all objects by php occurs
				register_shutdown_function('session_write_close');

				session_name($sid_name);
			}

			self::log('session handler registered');
		}

		/**
		 * Check if the given string is like a session id
		 *
		 * @param string $session_id
		 *
		 * @return bool
		 */
		private static function isSessionIdLike($session_id)
		{
			return is_string($session_id) AND preg_match("#^[-,a-zA-Z0-9]{32,128}$#", $session_id);
		}

		/**
		 * Fetch session data from database for a given session id
		 *
		 * @param string $session_id
		 *
		 * @return array
		 * @throws \Exception
		 */
		private static function fetch($session_id)
		{
			// usable: it is like a session id so it may be from us
			// exists: it was generated by us and stored in the db
			// data: the session data
			if (!self::isSessionIdLike($session_id)) {
				self::log(['invalid session id', $session_id]);
				self::$fetch_cache[$session_id] = ['usable' => false, 'exists' => false, 'data' => ''];
			} elseif (!isset(self::$fetch_cache[$session_id])) {
				$s_table = new OZSessionsQuery();
				$result  = $s_table->filterById($session_id)
								   ->find(1);

				$s = $result->fetchClass();
				if ($s) {
					self::$fetch_cache[$session_id] = [
						'usable' => true,
						'exists' => true,
						'data'   => $s->getData()
					];
				} else {
					self::$fetch_cache[$session_id] = ['usable' => true, 'exists' => false, 'data' => ''];
				}
			}

			return self::$fetch_cache[$session_id];
		}

		/**
		 * Asserts if there is an active session.
		 *
		 * @throws \OZONE\OZ\Exceptions\InternalErrorException
		 */
		public static function assertSessionStarted()
		{
			if (session_status() !== PHP_SESSION_ACTIVE) {
				throw new InternalErrorException('There is no active session.');
			}
		}

		/**
		 * Force session to be persisted in the database.
		 *
		 * Useful when you have some foreign key constraint on session_id.
		 *
		 * @return string the active session id
		 * @throws \Exception
		 */
		public static function persistActiveSession()
		{
			self::assertSessionStarted();

			$sid  = session_id();
			$data = session_encode();
			if (!$data) {
				$data = '';
			}
			self::$instance->write($sid, $data);

			return $sid;
		}

		/**
		 * Regenerate new session id.
		 *
		 * @throws \Exception
		 */
		private static function setNewSessionId()
		{
			$old        = session_id();
			$session_id = Hasher::genSessionId();
			$saved      = ini_get('session.use_strict_mode');

			// prevent our custom session id from being rejected by php
			ini_set('session.use_strict_mode', 0);
			session_id($session_id);
			// restore the saved config
			ini_set('session.use_strict_mode', $saved);
			self::log(['setNewSessionId', 'from' => $old, 'to' => $session_id]);
			self::updateSessionCookieHeader($session_id);
		}

		/**
		 * Gets cookie params to use for this request.
		 *
		 * @return array
		 * @throws \Exception
		 */
		private static function getCookieParams()
		{
			$cfg_domain   = SettingsManager::get("oz.cookie", "OZ_COOKIE_DOMAIN");
			$cfg_lifetime = SettingsManager::get("oz.cookie", "OZ_COOKIE_LIFETIME");

			if (!defined('OZ_SESSION_MAX_LIFE_TIME')) {
				define('OZ_SESSION_MAX_LIFE_TIME', $cfg_lifetime);
			}

			$cookie   = session_get_cookie_params();
			$path     = str_replace('\\', '/', dirname($_SERVER['PHP_SELF']));
			$path     = empty($path) ? '/' : $path;
			$lifetime = OZ_SESSION_MAX_LIFE_TIME;
			$httponly = true;
			$domain   = ($cfg_domain === "self") ? $_SERVER['SERVER_NAME'] : $cfg_domain;

			// TODO find a strong and secure way to set the domain in debug mode
			// Possible solutions:
			//  - force user to disable debug mode before going to production
			//  - or automatically/auto-magically detect production or development server/mode

			$is_debug_on = (bool)SettingsManager::get('oz.config', 'OZ_DEBUG_MODE');

			if ($is_debug_on === true) {
				// MAY HAVE SECURITY ISSUE AS LONG AS HTTP_HOST DEPEND ON USER REQUEST
				$domain = $_SERVER['HTTP_HOST'];
			}

			return [
				'lifetime' => $lifetime,
				'path'     => $path,
				'domain'   => $domain,
				'httponly' => $httponly,
				'secure'   => $cookie['secure']
			];
		}

		/**
		 * Update session cookie header.
		 *
		 * @param string $session_id
		 *
		 * @return bool
		 * @throws \Exception
		 */
		private static function updateSessionCookieHeader($session_id)
		{
			self::log(['updateSessionCookieHeader', $session_id]);

			return self::setCookie(session_name(), $session_id);
		}

		/**
		 * Close the session
		 *
		 * @link  http://php.net/manual/en/sessionhandlerinterface.close.php
		 * @return bool <p>
		 * The return value (usually TRUE on success, FALSE on failure).
		 * Note this value is returned internally to PHP for processing.
		 * </p>
		 */
		public function close()
		{
			self::log(['close', session_id()]);

			return true;
		}

		/**
		 * Destroy a session
		 *
		 * @link  http://php.net/manual/en/sessionhandlerinterface.destroy.php
		 *
		 * @param string $session_id The session ID being destroyed.
		 *
		 * @return bool <p>
		 * The return value (usually TRUE on success, FALSE on failure).
		 * Note this value is returned internally to PHP for processing.
		 * </p>
		 *
		 * @throws \Exception
		 */
		public function destroy($session_id)
		{
			self::log(['destroy', $session_id]);

			self::deleteCookie(session_name());

			$s_table = new OZSessionsQuery();
			$s_table->filterById($session_id)
					->delete()
					->execute();

			return true;
		}

		/**
		 * @param string $name
		 * @param array  $params
		 *
		 * @return bool
		 * @throws \Exception
		 */
		public static function deleteCookie($name, array $params = [])
		{
			$def    = self::getCookieParams();
			$params = array_merge($def, $params);
			// delete from the browser
			$time_in_the_past = time() - 43200;

			return setcookie($name, '', $time_in_the_past, $params['path'], $params['domain'], $params['secure'], $params['httponly']);
		}

		/**
		 * @param string $name
		 * @param string $value
		 * @param array  $params
		 *
		 * @return bool
		 * @throws \Exception
		 */
		public static function setCookie($name, $value = "", array $params = [])
		{
			$def    = self::getCookieParams();
			$params = array_merge($def, $params);
			$expire = time() + $params['lifetime'];

			return setcookie($name, $value, $expire, $params['path'], $params['domain'], $params['secure'], $params['httponly']);
		}

		/**
		 * @param $session_string
		 *
		 * @return mixed
		 */
		public static function decodeSessionString($session_string)
		{
			$current_session = session_encode();

			foreach ($_SESSION as $key => $value) {
				unset($_SESSION[$key]);
			}

			session_decode($session_string);

			$data = $_SESSION;

			foreach ($_SESSION as $key => $value) {
				unset($_SESSION[$key]);
			}

			session_decode($current_session);

			return $data;
		}

		/**
		 * Cleanup old sessions
		 *
		 * @link  http://php.net/manual/en/sessionhandlerinterface.gc.php
		 *
		 * @param int $maxlifetime <p>
		 *                         Sessions that have not updated for
		 *                         the last maxlifetime seconds will be removed.
		 *                         </p>
		 *
		 * @return bool <p>
		 * The return value (usually TRUE on success, FALSE on failure).
		 * Note this value is returned internally to PHP for processing.
		 * </p>
		 *
		 * @throws \Exception
		 */
		public function gc($maxlifetime)
		{
			self::log(['gc', $maxlifetime]);

			$s_table = new OZSessionsQuery();
			$s_table->filterByExpire(time(), Rule::OP_LTE)
					->delete()
					->execute();

			return true;
		}

		/**
		 * Initialize session
		 *
		 * @link  http://php.net/manual/en/sessionhandlerinterface.open.php
		 *
		 * @param string $save_path The path where to store/retrieve the session.
		 * @param string $name      The session name.
		 *
		 * @return bool <p>
		 * The return value (usually TRUE on success, FALSE on failure).
		 * Note this value is returned internally to PHP for processing.
		 * </p>
		 */
		public function open($save_path, $name)
		{
			self::log(['open', session_id()]);

			return true;
		}

		/**
		 * Read session data
		 *
		 * @link  http://php.net/manual/en/sessionhandlerinterface.read.php
		 *
		 * @param string $session_id The session id to read data for.
		 *
		 * @return string <p>
		 * Returns an encoded string of the read data.
		 * If nothing was read, it must return an empty string.
		 * Note this value is returned internally to PHP for processing.
		 * </p>
		 * @throws \Exception
		 */
		public function read($session_id)
		{
			$result = self::fetch($session_id);

			self::log(['read', session_id(), $result]);

			return $result['data'];
		}

		/**
		 * Write session data
		 *
		 * @link  http://php.net/manual/en/sessionhandlerinterface.write.php
		 *
		 * @param string $session_id   The session id.
		 * @param string $session_data <p>
		 *                             The encoded session data. This data is the
		 *                             result of the PHP internally encoding
		 *                             the $_SESSION superglobal to a serialized
		 *                             string and passing it as this parameter.
		 *                             Please note sessions use an alternative serialization method.
		 *                             </p>
		 *
		 * @return bool <p>
		 * The return value (usually TRUE on success, FALSE on failure).
		 * Note this value is returned internally to PHP for processing.
		 * </p>
		 *
		 * @throws \Exception
		 */
		public function write($session_id, $session_data)
		{
			self::log(['write', session_id(), $session_data]);
			$expire = intval(time() + OZ_SESSION_MAX_LIFE_TIME);

			$sq = new OZSessionsQuery();

			$result = $sq->filterById($session_id)
						 ->find();
			$s      = $result->fetchClass();

			if ($s) {
				$s->setData($session_data)
				  ->setExpire($expire)
				  ->save();
			} else {
				$client = RequestHandler::getCurrentClient();
				$token  = Hasher::genAuthToken($session_id);
				$s      = new OZSession();
				$s->setId($session_id)
				  ->setClientApiKey($client->getApiKey())
				  ->setData($session_data)
				  ->setExpire($expire)
				  ->setLastSeen(time())
				  ->setToken($token)
				  ->save();
			}

			return true;
		}

		/**
		 * Attach user to the current session.
		 *
		 * @param \OZONE\OZ\Db\OZUser $user
		 *
		 * @return \OZONE\OZ\Db\OZSession the current session
		 * @throws \Exception
		 */
		public static function attachUser(OZUser $user)
		{
			self::assertSessionStarted();
			self::persistActiveSession();

			$uid    = $user->getId();
			$client = RequestHandler::getCurrentClient();

			if (!$client->isMultiUserSupported()) {
				Assert::assertAuthorizeAction($client->getUserId() === $uid);
			}

			$session_id = session_id();
			$sq         = new OZSessionsQuery();

			$result = $sq->filterById($session_id)
						 ->find();
			$s      = $result->fetchClass();

			if ($s) {
				if ($s->getUserId()) {
					throw new InternalErrorException(sprintf('The session (sid: %s) is already in use by (user: %s) and should not be attached to (user: %s).', $session_id, $s->getUserId(), $uid));
				}

				$s->setUserId($uid)
				  ->save();
			} else {
				// the session is supposed to exists in the database but was not found
				throw new InternalErrorException(sprintf('The session (sid: %s) is supposed to exists in the database but was not found.', $session_id));
			}

			return $s;
		}
	}